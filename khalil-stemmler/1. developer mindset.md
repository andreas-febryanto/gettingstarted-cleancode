# Developer mindset

> Professionalism, growth from failure, and design thinking.

## Software Craftmanship

I've realized that mentorship, the way I learned the trade of landscaping, **has been practiced for generations**, and stems back to medieval Europe with *masters* and *journeymen*.

Back in those days, the *master* demonstrates the correct way of completing a task; then, the journeymen attempt to imitate the master's skills and get corrected for any mistakes.

Programming, on the other hand, is an incredibly young(and turbulent) trade. We expect new developers to learn what it takes to be a professional independently, and often, there's a detachment from the older generation of programmers to the newer ones.

It's not surprise that so many developers are left confused, unequipped, and unguided to work *professionally*, **because we, as an industry, haven't converged on what it means to work professionally.**

And let's consider that developers do know the right things to do. Non-technical project managers make it hard for us. They can't see the value in activies like TDD or refactoring that just looks like not-working-on-features.

> Being a professional means taking **responsibility** for our careers, clients, and community. It also means taking **pride** in our solutions, working with **pragmatism**, and seeking to improve our reputations with the excellent work we do continually.

### A brief history of software development

#### Programming picking up speed(50s)

In the 50s, computer science picked up. We started to understand the lifecycle of how software is *planned, designed, built, and maintained*. We called the **SDLC(Software Development Life Cycle)**. Planning -> Analysis -> Design -> Implementation -> Testing & Integration -> Maintenance.

In 1956, we came up with the Waterfall model: an iterative approach to building software.

In later(80s and 90s) come up XP(Extreme Programming), FDD(Feature-Driven Development), Scrum, and so on. We call this *software development methodologies*, and they act as a **framework to move through each phase in the SDLC**, specifically designed to circumvent bad coding practices and pitfalls.

for eg: in XP the customers writes acceptance tests, that way, developers know what they should build and can define completion more precisely.

#### The software crisis of the 60s-80s

We discovered most of the **major problems** in software engineering that would continue to plague us today; they are based predominantly around productivity and quality.

In 1964, IBM announced the IBM System/360: the first general-purpose computer system with cross-compatibility between models. Cross-compatibility was huge back then; the ability to finally run the same programs on every system instead of needing to stick to older, slower models to run the programs you needed for everyday use was revolutionary.

While spectacular when it was finally released, the productivity failure was legendary. It took IBM an entire decade and 1000 developers to complete the system because they didn’t develop a sound and understandable architecture. The influential book “The Mythical Man-Month”,written by Fred Books, is based on his observations managing the IBM system’s development. By 1975, after completing the project and publishing the book, we, as an industry, came to learn that”adding manpower to a late software project makes it later”.

#### Dot-com bubble, OOP, and Extreme Programming(1995-2001)

We called the 90s the dot-com boom because the internet completely took over. At some point, companies realized that if they could deliver internet-based products faster, they’d hold a massive competitive advantage.

Unfortunately, many teams were still using iterative software development methodologies like Waterfall, which, in this new climate of needing fast, quick, and snappy changes (which we continue to expect today), typically led to both low productivity and quality.

Two other significant things happened around this time in 90s:

1. Object-oriented programming became the most popular programming paradigm, surpassing procedural programming

2. We formalized the Extreme Programming (XP) methodology

OOP became the go-to for many developers because it made it easier to create domain models that more acutely captured the essence of the business and were easier to change as new requirements came in

#### Agile(2001-today)

Agile is about delivering value incrementally instead of all at once. 

In February 2001, seventeen influential developers, including those who created those methodologies, agreed to meet up at a ski resort to discuss better software delivery. The goal was to see if they could agree on something to be written down.Miraculously, by the end of the trip, the group had agreed upon what would be called the Agile Manifesto, hence, creating Agile and changing the trajectory of our industry forever.

**The Agile Manifesto** is as follows:

- **Individuals and interactions** over processes and tools

- **Working software** over comprehensive documentation

- **Customer collaboration** over contract negotiation

- **Responding to change** over following a plan

#### The(Misled) Era of Agile

The first is the introduction of Agile coaches. Companies would hire Agile coaches to come to their site and help them perform an Agile transformation by introducing processes and Agile frameworks like Scrum. It’s important to note that these Agile coaches did nothing to help developers change how they write code — they just introduced process.

The second change is that developers became generalists. Agile introduced the need for well-rounded developers. Today, developers need to know how to design, develop across the stack, set up continuous integration, deployment, databases, and know how to speak with customers and gather feedback.

While Agile promised the resolution of quality and productivity issues, and many companies dived right in, fixing their process, but still feeling plagued with both problems. And so came the Agile-haters, the death marches, and more failed projects.

**Why didn't Agile work ?**

A lot of companies failed to realize that for Agile to work, two things are required:

1. Process

2. Technical excellence

**Process**:

- Scrum
  
  - daily scrum
  
  - retrospective
  
  - backlog
  
  - sprints

- Technical excellence
  
  - XP
    
    - TDD
    
    - pair programming
    
    - continous integration
    
    - YAGNI
    
    - Simple Design
    
    - DDD

Not only that, but non-technical managers didn’t see the value in XP practices like pair programming and Test-Driven Development. “Why have two developers working on the same thing when you could be getting more done working separately?”. “And you’re telling me it might take longer for you initially if you do TDD? Then don’t do it.” The top-down, I’m smarter than you, so do what I say, industrial, factory-worker attitude applied to software developers has enabled non-technical leaders to successfully push back on things developers see the long-term value in, but they, themselves do not value as much as delivering on time.

#### Software Craftmanship(2006-today)

There had been some talk about Software Craftsmanship before. The first book to hint that software development might be more of a trade than science was “The Pragmatic Programmer: From Journeymen to Master.” It drew comparisons between how developers learn and gain seniority to the apprenticeship model in medieval Europe, and was one of the first texts to attempt to distill some sense of professionalism toward software developers.

Since things weren’t going the way we wanted them to with Agile, and because we deviated from technical Agile frameworks like XP, in 2009, a group of developers aimed to produce something to be written down that could concisely describe the craftsmanship movement. Eventually, we created the Software Craftsmanship Manifesto. The manifesto, printed below, took theAgileManifesto’s values and pushed itfurther, promoting technical excellence and professionalism.

### The Software Craftsmanship Manifesto

As aspiring Software Craftsmen we are raising the bar of professional software development by practicing it and helping others learn the craft. Through this work we have come to value the following:

- **Not only working software**, but also well-crafted software

- **Not only responding to change**, but also steadily adding value

- **Not only individuals and interactions**, but also a community of professionals

- **Not only customer collaboration**, but also productive partnerships

#### Back to Basics(XP)

we’re seeing some positive changes in the software industry around Agile and Software Craftsmanship.

First, the software craftsmanship community is growing. Developers worldwide are organizing meetups, signing the original manifesto, and spreading the word of professionalism. This community may very well be the one that comes together to popularize and standardize the approach to solving that 60-year old productivity and quality problem.
Secondly, in 2019, a frustrated Uncle Bob published a book titled “Clean Agile: Back to Basics”, which is almost entirely a walkthrough of the technical practices of XP.

### Craftsmanship: Professionalism in software development

#### Definition

Software Craftsmanship is a professionalism mindset. It’s not about if you have a certification, if you’re a senior developer, or if you practice TDD all the time (though you should.

#### Are you a software craftsman ?

There’s no magic to it. Even if you don’t like the label and don’t want to call yourself a craftsman, that’s totally cool. What’s important is that you do these things

#### Art, science, engineering practice, or trade

Ultimately, the software development we do today as web developers is about helping clients/companies achieve their goals (make money, save money, protect revenue). That is predominantly what we do.

### Understanding the manifesto

#### Not only working software, but also well-crafted software

It's important to remember that **working software** can also be software that's:

- hard to change

- difficult to understand

- slow

But *well-crafted* software is software that is testable, flexible, and maintainable. It's also software that gets better over time, growing in value as you put more time and care into it.

#### Not only responding to change, but also steadily adding value

Adding value isn’t just adding new features or fixing bugs. You can consider adding value to be continually improving the structure of the code, keeping it clean, testable, flexible, and maintainable. It costs a lot of money to perform re-writes, and though every application has a life-span, usually — if that’s the only feasible option on a relatively young application, it means we’ve failed.

#### Not only individuals and interactions, but also community of professionals

To push this industry forward, we need to share knowledge, learn from others, inspire, mentor and prepare the next generation of craftsmen.

Because software development is so young, and because there isn’t yet a standard for many things, knowledge sharing and mentorship are incredibly important. We don’t want to lose what we’ve discovered over the last 40 years.

#### Not only customer collaboration, but also productive partnerships

Instead, treat your employer as your customer, the same way you would if you were just a consultant or a contractor. Some important things to remember:

- Your employer isn't responsible for ensuring you grow professionally - you are.

- Your employer isn't responsible for ensuring you get a book budget, training, or sent to conferences and seminars - you are

- Your responsibility is to **treat your employer as  a customer and provide them with excellent service(advice, consulting, development) and help them achieve their goals by performing high-value activities, even if that sometimes doesn't mean coding.** Sometimes it means giving a talk, a presentation, or writing a blog post.

### Your homework

#### To write well-crafted software

**Care about what you do**

**Learn techincal best practices**

**Always be improving yourself**

**Know your industry**

**Learn the domain**

**Ruthless simplicity**

**Practice**

#### To steadily add value

**Apply the Boy Scout's Rule** - The Boy Scout's rule is to leave the campground cleaner than we found it.

**Refactor, guarded by tests**

**Be brave**

**Learn and apply XP**

**Delight customers, helping them achieve whatever they want**

#### Engage in the community

**Learn from others**

**Mentor less experienced developers**

**Share what you know**

**Socialize with others**

#### Consider yourself a partner

**Take responsibility for your own learning**

**Take responsibility for success/failures**

**Help them see the value of technical practices**

**Don't overwork yourself**

**Privide value, even when it's not coding**

---

## Growth

> Not only are people with a growth mindset not discouraged by failer, but they don't actually see themselves as failing in those situations - they see themselves as learning.

### Two mindsets

Our behavior and relationship with success and failure (both professionally and personally), has to do with our mindset.

###### Fixed mindset

People with a fixed mindset assume they can't improve. They believe that their personality character, and intelligence, are static and circumstantial.

> **The fixed mindset assumes a deterministic view of the world:** it's just the way it is.

###### Growth mindset

People with a growth mindset believe that they can improve by learning. Who they are today, is not who they have to be tomorrow.

> **The growth mindset assumes that nothing dictates who we are except us - it's free will:** and we can accomplish spectacular things if we lean from our mistakes.

### You need to have a growth mindset as a software developer

We'll never be able to know everything up front. We need to know if our solutions are clean and well-structured, and we grow by using failure as information.

Fixed mindset developers:

- Avoid challenging situations

- Enter discussions to express themselves, not to potentially change their minds

- Develope code in a vacuum, away from others, in an attempting to avoid receiving feedback

- Aren't great listeners

- View negative feedback as a personal attack on their character

- Give up easily

- Don't put in more effort - since their abilities are static, more effort is a waste of time

Growth mindset developers:

- Put themselves in situations where they have room to grow

- Involve others when they develop code(pair programming, discussions, reviews)

- Aren't afraid of looking silly or not knowing the answers up-front(they believe they can find the answers)

- Are great listeners - and always challenge their own way of solving a problem using someone else's POV

- Treat negative criticism as a way to learn how to grow

- Don't give up easily

- See putting in effort as the way to accomplish more

- Are software craftsmen

### Final thoughts

###### Life is more fun

The capacity for happiness and fulfillment you can have with a growth mindset is the biggest reason why I advocate for trying to adopt one. To me, life becomes more fun. From a position of privilege, it can be enjoyable to look at the world as a set of systems that we get the opportunity to master, starting from nothing.

##### Craftsmanship requires a growth mindset

In Craftsmanship, we learned that the mentorship (or apprenticeships, in more formal trades) one of the best ways towards mastery. For that to work, we need a growth mindset.

---

## Design Thinking

One thing I love about design principles like SOLID, YAGNI, or SoC is that they become engrained into your professional way of ensuring a baseline of good structural code quality.

If you ever run into situations where you're not sure if you're doing things correctly, design principles sit in the back of your mind and become a voice of reason.

> ... any fool can write code that a computer can understand. Good programmers write code that *humans* can understand
> 
> -Martin Fowler-

**Structure vs Developer Experience**

Design is a push and pull of priorities. In real world, office furniture manufacturers need to produce items as cost efficiently as possible. Conversely, consumers want good quality furniture, but don't at a reasonable price.

**Other important balances to maintain:**

- Note-taking = context vs compression

- Security system = security vs ease of configuration

###### Structure

The "structural side" of software design is the technical, computer-science stuff. I'm talking about doing all the right things, following best practices, making the implicit -- explicit, and adhering to design principles like SOLID, YAGNI, PoLS, and Separation of Concerns. The design principles one, helps us write more sturdy, robust, flexible, and testable code.

The challenge with structure is that the more we have, the more challenging it can be for other developers to become productive in our codebases. A higher learning curve typically means it takes more time to learn your options for completing a task, how to perform the ooption, and how to know if you're doing things correctly.

###### Developer Experience

Where UX design is about designing applications for end users, **DX design is about designing APIs, tools, languages, frameworks, and codebases for developers.** And you're always writing code for another developer down the road.

When developers have a positive experience and run into few issues adding, changing, improving, or removing features in your codebase, we're more inclined to call that a **maintainable codebase.** It's what makes us say, "this is such a nice codebase, I love working in it" or "this legacy code is terrible -- we should just rewrite it".

When it's easy to do what you needed to do, with minimal learning or additional considerations required, that usually means that the codebase, library, framework, or whatever doesn't have a lot of mandatory structure that you need to first familiarize yourself with to be productive.

###### Structure vs Developer Experience: Angular and React

Angular, if you look closely, is thoughtfully crafted to promote the use of OO software design best practices. To become productive with Angular means learning TypeScript, brushing up on your OOP skills, and learning the Angular-way to get things done.

React, a UI library, on the other hand, is a lot more functional and flexible. Developers are capable of being productive with React a lot faster because the API is smaller, there's less to learn, and it contains fewer structural policies that mandate how you can write code within it.

The challenge is **maintainability**. How would you enforce structure in a library designed to have as positive of a developer experience as possible ?

Perhaps if you were to use React and you needed a nice structure/developer experience middleground, writing your React code with TypeScript could be the way to get there.

###### Structure vs Developer Experience in Practice: OO vs FP

OOP is hard because it's easy to create structure, but hard to make things discoverable, understandable, and delightful to use.

FP is also hard, but that's because it's delightful and easy to get started, but hard to impose structure.

Goal: Balancing the two

Essentially:

- Too much structure, developer experience is low

- Too much looseness and flexibility, while developer experience may be high, *structure* is low.

It's important that we practice design principles, use design principles, use design patterns when they make sense, and strive for structurally high quality code, but it's also important to develop code that keeps the developer experience high.

### Human-Centered Design

HCD is a design philosophy that pus the users' needs, behavior, characteristics, pain points, and motivations first. ex: instead of just designing something that works, we brainstorm, test, and implement based on what we know about the humans we're designing for.

Discover -> Define -> Design -> Prototype & Test -> Plan & Implement

###### How is this helpful for us ?

Normally, if we were building an app for a particular set of users, like a dating app or something, we'd have to get out there and actually interview the users, like a dating app or something, we'd have to get out there and actually interview the users to learn more about them and find out about their needs.

Since we're trying to figure out how to write code so that it can be easily maintained by our coworkers and future maintainers, this process is a lot easier. We're also the users who need clean code in the first place.

###### Developer goals

- I need to know how to run the app

- I need to know how to run the tests

- I need to understand how and why code is organized the way it is

- I need to understand how the domain is expressed in code and where policy belongs

- I need to understand how to add a new feature and know where it belongs

- I need to locate a specific feature withing the code so that I can change it based on a new specification

- I nee to be able to run through the code in debug mode to test a feature or debug a bug

- I nee to be able to improve code over time without breaking anything

### Knowledge in the Head vs World

Each of design principles we just mentioned in the last section capitalizes on our knowledge. Knowledge is involved in how we discover what we can do and what things mean.

###### Knowledge in the Head

- Fast(like RAM)

- Hard at first, but practiced

- Muscle memory

- Experiental and Learned

- Invisible

Knowledge in the head is stuff that we know. It's also the stuff we can do with little effort because we've invested the time and energy into learning them. ex: driving a car has become muscle memory for a lot of people. But if you were to think back to when you first started driving, you might recall your actions werw substantially more calculated.

Knowledge in the head comes from **conceptual models**(unserstanding) and **constraints**(cultural, semantic, and logical ones)

###### Knowledge in the World

- Interpreted

- Easy to use at first

- Can be reminded

- Learning not required

- Must be visible

Reminders are the best examples of knowledge in the world. ex: most ATMs guide you along with what steps to take next. Imagine you had to learn how to take out money. Imagine a world where withdrawing money from an ATM took the same amount of tribal knowledge as changing a tire.

Knowledge in the world is expressed withing **affordances, signifiers, mappings** and **physical constraints**.

Why are we talking about this ? We're in establishing how to create **human-centered codebases**. There are some activities that you want developers to spend time learning and there are some that you want to take absolutely no time to learn.

Things that you'd like developers to utilize knowledge in the *head*and spend time *learning*:

- The domain. Developers need to spend time and learn the domain to make good design decisions.

- The architecture of the application. You want developers to have a solid understanding of how we're building the application. It may take some time to fully understand, but that's a necessary learning.

- The features withing the project, what they do, and how to add new ones.You want developers to easily discover features, and that's trivial if we're using screaming architecture. As for what the features do and how to add new ones, this takes not only learning the domain, but the technical constructs used to realize the features as well. This is not something that can be merely interpreted as world knowledge. The responsible thing to do is to spend energy understanding. This can be helped through the use of BDD-style tests that expose the intended behaviour of the features.

Things that you'd like developers to spend zero time on learning and you'd like them to merely need *interpret* and *react* to.

- Type errors. By using TypeScript, we force other developers to deal with errors as they occur, at compile time.

- Failing tests. How are you supposed to keep track of if you broke something or not ? we practice TDD, and while we're coding, if we notice that we've done something to put the app into a broken state, we know that we now have to deal with the issue right there at that moment in time.

- An easy-to-reason-about folder structure. The names of the files and folders(signifiers) should help guide us towards a feature, component, or module of code that we're looking for.

- Pre-commit checks. How do you get developers to remember to run the tests and lint their code before they commit ? You don't. We enforce pre-commit policy with tools like Husky. And if tests fail or code needs to get cleaned up.

### Affordance

> A relationship between what we know we can do AND an object's physical properties

![3.1.1 affordance.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.1.1%20affordance.png)

###### Why is this useful ?

If we haven't seen something before, even though it's new, if it has physical properties that we're familiar with, then we may be able quickly **discover what we may be able to do with it**. 

![3.1.2 affordance.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.1.2%20affordance.png)

ex: typewriter. Keys are buttons, and buttons afford pushing. Therefore, you'd likely be able to figure out how to use a typewriter pretty quickly. If the physical properies are visible and familiar, we will know what actions we can perform.

###### Affordances in software development

**1. Programming languages**

Things have affordances. Things that are possible in one language may not be possible in another. When programming languages express concepts differently, or are missing features that others we're familiar with do have, that reduces the set of options we know of to accomplish our goal.

example: if someone told you to build a quick in-memory solution to keep track of users that visited a site, recordint them by userId, how might we do that ?

```ts
in JS:
// Hashtable in JavaScript
const visitors = {};
function saveVisitor (userId) {
    visitors[userId] = userId;
}

in java:

import java.util.*;
class HashTableDemo {        
    public Hashtable<String, String> visitors;
    public void saveVisitor (String userId) {
        this.visitors.put(userId, userId);
    }
    public static main void (String args[]) {
    // creating a hash table
    this.visitors = new Hashtable<String, String>();
    }
}
```

**2. Design patterns**

Some languages have a good affordances for certain design patterns, some have poor affordances, and sometimes, it's completely impossible.

To implement the **observer pattern** in Node.js is trivial, we could just use the EventEmitter API. On the other side, to implement the **abstract factory pattern** in JS is nearly impossible to do properly, because JS doesn't have any the abstract keyword.

###### How to do affordances well

Since most of use are coding with the goal of **writing code in a way that makes it easy for future maintainters to understand, improve, add, change, and remove features**, we have to ask ourselves, what are the necessary affordances ?

Well, code isn't really **physical**. It's more or less *invisible*. But the form of code is **documentation & reading**.

At a high-level, as far away from the actual code as possible, we feedforward with:

- Repo docs that shows examples, how to install, run, run the tests, contribute, and learn more about the project domain and architecture.

- Folder structure and file/folder names.

- BDD-style tests that explains what the code does.

At the next level down, we're concerned with:

- Formatting, style, file size

- Modular units

- Comments when necessary

### Signifiers

> When an affordance isn't discoverable, signifiers help. They are mark or sound, and can communicate intended behavior to a person.

Signifiers comes from something called *semiotics* -- the study of signs and how meaning is derived from them.

A sign can be thought of as two-part relationship between a signifier and a signified.

- Signifier = the physical thig you see, hear, sense, imagine

- Signified = the mental content that the signifier produces

###### Real-life examples

**Intentional vs Accidental**. Signifiers can be both **intentional** and **accidental**.

- Intentional - it was conciously created to help users discover what they can do with object. ex: A PUSH or PULL label on a door.

- Accidental - A trail or a path made visible by peoople walking along it over a long period of time. This signals that it's a path that can be taken.

![3.2.1 signifier.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.2.1%20signifier.png)

###### Why is this useful ?

![3.2.2 signifier.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.2.2%20signifier.png)

Signifiers are  a cheap way to enhance the *discoverability* of *affordances* and make sure that the *feedback* is understood clearly by the user.

###### Signifiers in software development

**Intentional signifiers**

- **Design patterns**. There are two ways to recognize a design pattern in code. The first way is to see the code, the structure, and recognize that it's a pattern. ex: if you ever see a private constructor, and a static create method, it's likely we're looking at a **factory method**. The second way to see the pattern name in the actual *name* of the class or function, like StudentController.

- **Comments**. Describe what something is, rather than allowing the code to describe what it does(we generally discourage these).

- **Tests**. if we do BDD-style tests, we signify the problems that the code solves.

**Accidental signifiers**

- Dead, commented out code, or todo comments left for too long. These signify that the related code might be a work in progress

- Too many nested conditionals -- signifies to us that this is a place that may contain a lot of application or domain logic

- Thin controllers -- signifies that the application and domain logic is being handled elsewhere and that the architecture may be more robust than a simple MVC app.

- Code smells and anti-patterns. They signify that the code has issues for us to tend to.

###### How to do signifiers well

Use good names for files, folders, variable and classes, write tests, make error handling explicit, and utilize design patterns when appropriate.

### Constraints

> Constraints limit the set of possible action we can take in certain situations

Constraints can be physical, cultural, semantic, and logical.

![3.3 constraints.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.3%20constraints.png)

###### Real-life examples(physical constraints)

Restricts the way in which objects can be moved or manipulated.

- We can't force puzzle pieces to fit in spots that they physically don't belong.

- You can nail a hammer into the wall with a nail. You can't nail a *hammer* into the wall with a *nail*.

###### Real-life examples(cultural constraints)

Constraints a situation by providing a set of allowable actions in social situations.

- How we behave in an elevator with a stranger. In North America, it can be impolite and uncomfortable to make direct eye contact with a stranger in elevator.

- It might seem a bit odd if we opt to offer our bus seat to an athletic person, while neglecting elderly, pregnant, or disabled people.

###### Real-life examples(semantic constraints)

Relies upon the meaning of the situation to control the set of possible actions.

- We hear helmets to ride bikes or skateboard because we are delicate human beings that, if we hit our heads, there's a good possibility of serious injury or death.

- If somehow we discovered immortality and it was impossible for us to die, helmets would be useless and there would be no reason for us to use 'em.

###### Real-life examples(logical constraints)

Relies upon arithmetic, and logical proofs to constrain the set of possible actions.

- Who took my food from the fridge ? If all but one of our roomates had valid alibis, it must have been that person.

###### Constraint examples in software development

- Static type checking

- Value Objects use the Factory Pattern to enforce constraints against creating domain objects

- Access modifiers

- Language rules. A const cannot be redeclared. A static method can only be accessed through its class, not through an instance of the class. In the OOP, we rely on these language rules to enforce policy, reducing the total surface area for ways developers can misuse our solutions.

- Strictly-typed errors. These force you to deal with potential error states instead of throwing them at you

###### How to use constraints well

**Resource**: it's remarkable how much information is conveyed by limiting the surface area of what's possible.

### Mappings

> Mapping is the relationship between two sets of things

Typically, when we're talking about mapping, what we're really concerned with is the **layout of controls with respect to the devices they're hooked up to**.

###### Real-life examples

![3.4.1 mappings.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.4.1%20mappings.png)

Since the example on the right is a lot easier to **discover** how to use the stove correctly, we'd say the mapping is a lot better. The best way to implement mapping is to **place the control directly on the item that needs to be controlled**. If we had to thing about how to do mapping the best, it's:

- 1. Mount controls directly on the items to be controlled.
  
  2. Mount controls as close to the items to be controlled.
  
  3. Mount controls in the same spatial arrangement as the items to be controlled.

![3.4.2 mappings.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.4.2%20mappings.png)

Mount controls directly on the items to be controlled is impossible, but if we designed it a little differently, we might be able to mount controls closer to the items to be controlled:

![3.4.3 mappings.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.4.3%20mappings.png)

###### Why is this useful ?

![3.4.4 mappings.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.4.4%20mappings.png)

When mapping makes sense, we construct a *conceptual model* faster.

###### How to do mappings well

To do mapping well, we have to obey 2 principles: *grouping* and *proximity*.

- Grouping - Place *related* controls together.

- Proximity - Place controls *close* to the object that they control.

**Grouping**

![3.5.1 grouping.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.5.1%20grouping.png)

The grouping is entirely off, and this would create a ton of confusion. It's an easy fix, we ensure the related controls together.

![3.5.2 grouping.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.5.2%20grouping.png)

**Proximity**

![3.6.1 proximity.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.6.1%20proximity.png)

with the light switch all the way down the hallway, and with other rooms in proximity, it's less clear which room the switch is meant to control the lightning within.

![3.6.2 proximity.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.6.2%20proximity.png)

###### Mappings in software development

**Grouping**

- Cohesion - do we group related methods, classes, and function together ?

- Single Responsibility Principle & boundaries - do we enforce boundaries between things sot hat they have a single reason for change ? or can a change to the code potentially cause a ripple inanother part of the codebase ?

**Proximity**

- Coupling - If components rely on and are frequently changed together, they should be relatively close to each other for better discoverability and less time spent flipping between files and folders.

- Anemic domain models - do we keep controls that change state as close to the objects(models) as possible? or do we maintain *slim* models? ex: UserManager class that does *create, update, setPermissions* operations on the User model, leaves the User model responsible for nothing. This can lead to duplication and a lack of encapsulation.

- API design - The DOM API has good mapping. It keeps the methods that operate against objects, physically on the objects themselves. ex: document.querySelector returns an object that contains the methods that may be performed against it.
  
  ```js
  // Great!
  const node = document.querySelector('a').getAttribute('href')
  
  Imagine if you needed to construct a secondary class or wrap the result of document.querySelector in another object to call getAttribute on the HTML node
  // This API doesn't exist, but imagine you had to do
  // this wrapping everytime you wanted to execute a method
  // on a node returned from the DOM.
  const node = document.createExecutableNode(nodeResult);
  node.getAttribute('href')
  ```
  
  Some java APIs are like this, which create challenge and adds another level of knowledge necessary for the developer to know **how they may use** what was returned. Consequently, this is also the Law of Demeter(Principle of Least Knowledge), ensuring that an object doesn't know too much about the other one.

### Feedback

> Communicating the results of an action

It's expected that feedback will be immediate. If users don't get feedback immediately, they might assume that the item they've tried to interact is broken or slow, even if it's working perfectly in the background. Success, loading, failure states are important to report every step of the way.

###### Types of errors

There are two kinds of errors: *slips* and *mistakes*

![3.7.1 feedback.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.7.1%20feedback.png)

- **Slips**: This is when the goal or plain **is correct**, but the *sequence* is off. In these cases, it's OK -- we can point the user in the right sequence of actions.

- **Mistakes**: This is when the goal or plan is **not correct**. This is bad, and you want to avoid this. It means that the user is about to go completly astray or it means that they have gone completely astray, going about accomplishing their goal in an incorrect way.

###### Real-life examples

- Elevator buttons - They light up to indicate that the elevator is now moving.

- Making a purchase on a website - you want to see the loading spinner as soon as possible otherwise you might assume your transaction hasn't started.

###### Why is this useful ?

Feedback is the other half of the seven stages of action. It's what helps to build our conceptual model. After interacting with something, the next stages are perceive, interpret, and compare.

![3.7.2 feedback.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.7.2%20feedback.png)

###### Feedback in software development

- The CQS principle. if a **command** is invoked, getting no response is the feedback to signat that is succeded. Getting an error signals that it failed. If a query is invoked, getting no response is the feedback to signal that something failed(or is slow). Getting data back signals that it succeded.

- Command-line utilities. Communicating progress and the current state of a long-running task is important. Think 'bout how useful it is to see your progress when you're npm-installing some dependencies.

- Clicking the submit button in a form.

- Autocomplete -  this depicts the total set of possible actions, it shows that we're writing a statement using the correct object

- Compile-time type checking -  shows us immediately if what we're doing is legal or not

- TDD - we can immediately determine when we've put the system into a broken state, and we can work to fix it.

###### How to do feedback well

> Communicate the result **immediately**. As soon as possible.

### Conceptual Model

> Conceptual models are the true understanding of how something works.

They are high-level explanations of how something works. They're imperfect, they often skip or gloss over details, but they're good enough *mental models* of things that helps us understand how to use things.

###### Real-life examples

- Elevators - You might not know everything about the machinery behind elevators, but you generally understand how they work having spent time using them.

- The cloud - They don't need to know that your data gets saved in databases somewhere on servers likely running on AWS EC<sub>2</sub> containers. It's a good enough understanding for them to know how to utilize it.

###### Why is this useful ?

A good conceptual model allows up to predict the effects of our actions.

![3.8 conceptual model.png](A:\PLAYGROUND\gettingstarted-cleancode\khalil-stemmler\images\3\3.8%20conceptual%20model.png)

###### Conceptual models in software development

- Design Patterns. Design patterns are signs that point to conceptual models. When you think of the Builder pattern, Factory pattern, Observer pattern, etc. Each design pattern has a name that helps to conceptualize what it means. ex: Factory Pattern implies that a component acts a the sole place to create an object.

- Encapsulation. Even if you don't fully understand reactivity in React, you know that React will re-render when you data changes.

- Constructs. Controllers, routes, client-side libraries like React, etc.

###### How to do conceptual models well

Use encapsulation to abstract away complexity that we don't want the client to have to think about. Optimize all the feedforward principles and good feedback to help create a better conceptual model. 

### Testing your code for cleanliness

Ask a friend.Being able to determine if your code is clean is more or less something that **comes from experience working in both very clean codebases and unclean codebases of substantial size**.

###### Ask: What does my code do ?

Test against **how quickly they're able to understand what it does.** Don't even tell them the problem domain. Allow them to look at the files, folders, classes, and variable names. with this question, we're testing against:

- Readibility

- Clarity

- Brevity & succinctness

how to improve:

- Good names(classes, variables, methods, folders, files)

- Encapsulation(simplify APIs)

- Intention revealing interfaces

###### Ask: Find the code that needs to be changed

Test against **how quickly they can find the code that needs to change** for a feature. we're testing against:

- Locatability, scannability, structure

Things that massively influence this are:

- Good names(classes, variables, methods, folders, files)

- Smaller files

- Good packaging(coupling of constructs involved in a feature)

###### Ask: Change this code without introducing bugs

**How safely can they change the code without breaking other features**? we're testing:

- Stability

- Flexibility

the concepts we care most deeply about are:

- Tests

- Coupling

- Dependency Inversion or decomposition of code

- Boundaries & separation of concerns

- Type safety



### Summary on Design Thinking

These principles aren't just for the UX designers. They were formalized to help communicate how human beings **discover** and **understand** how to use things.

Human-Centered Design is a topic worthy of more research. I think every software developer, regardless of if you code UIs or not, should read this book. I suggest you spend some time learning more about design. I recommend the book, “The Design of Everyday Things, by Donald Norman”.

If you’re looking for a way to quantitatively measure design effectiveness, check out GOMS. Next time your friend says they can code faster that you in Vim vs. you with your keyboard and mouse, try measuring a task using a GOMS test.
