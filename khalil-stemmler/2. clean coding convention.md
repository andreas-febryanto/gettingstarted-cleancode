# Clean Coding Convention

> Developing your own set of principled coding conventions to produce high quality software possible using industry standards, tools, approaches,a nd methods



**table of content:**

- Project planning

- Documentation

- Organizing things

- Formatting & style

- Comments

- Naming things

- Errors & exception handling

- Testing

- Refactoring

- Architecture basics



## Project Planning

##### Notes

How do you plan a new project ?

- A lot of times developers - they start building out of the API
  
  - API first
    
    - Benefits:
      
      - We're starting imperatively. We're actually starting out  by building something
    
    - Drawbacks
      
      - It's easier to miss small nuances
    
    - Works well for:
      
      - CRUD apps
    
    - Doesn't work well for
      
      - Apps with domain logic complexity
  
  - Database first

---

## Documentation

---

## Organizing Things

##### Why code organization matters

- The way you organize code has a profound impact on:
  
  - How long it takes to develop new features
  
  - How long it takes to locate a feature
  
  - How much mental energy it takes to change code
    
    - Flipping back and forth between files & folders
  
  - Knowing where new code should go

- Colocation

- Different types of packaging and the ergonomics of 'em'

##### Practical naming

###### Principles

- Use conventions
  
  - Your source code goes in the src/ folder
  
  - docs go in the docs/ folder
  
  - config
  
  - examples
  
  - dist/build/ for compiled code

- Keep your code DRY / don't repeat yourself with files

- Group files related to a feature close to each other(colocate files with high cohesion)
  
  - Experiment and notice how often you're flipping around and getting fatigued
  
  - Examples:
    
    - DDD forum use cases

- As flat as possible

- Screaming architecture

- Shared folder for anything that doesn't

- Use package by infrastructure on small projects

- Package by feature on larger projects

Great examples:

- DDD forum

- Apollo Client open source library

###### Organizing and context

Here we have all of these files adhering to the same naming convention.

```ts
useCases/
    createUser/
    editUser/
    deleteUser/
        DeleteUserUseCase.ts
        DeleteUserErrors.ts
        DeleteUserController.ts
        DeleteUserResolver.ts
```

###### How to settle design arguments

- In subjective converstaions about design, there's only one way to decide - observe users. This is what we do in Human-Centered Design
  
  - GOMS - this process exists so you can measure the efficiency it takes a user to accomplish a task
  
  - If you're uncertain about some approach to designing your code or making so API easy to use, this is a way to handle that.

---

## Formatting & style

> Each of the following suggestinos are tactical ways for use to improve the design of our code to promote better **readibility** & **discoverability**.
> 
> It's important to address that **formatting is increadibliy subjective**. SOme developers prefer to use tabs over spaces; some prefer using max line lenghts of 80 characters. These subtle choices that will always be debatable.

If you're working on a team:

- Establish the formatting rules that you would like every to adhere to.

- Enforce those rules.

##### Objective readibility truths

I said that formatting is subjective. This is true of anything visual. Code looking *good* is **extremely subjective**

```ts
java developers may prefer to write conditional like this:
if(isAccountOverdue) {
    ...
}
while C developers may prefer:
if(isAccountOverdue) 
{
    ...
}
```

Is one approach better than the other? Who knows. That's an age-old debate. However, since you and i are both human beings, **there are certain physiological limitations we all share in common**

because we are human:

- Without proper use of *whitespace*, code becomes virtually impossible to read.

- Without *consistency*, we can't build turn on the pattern matching algorithm in our brains. THis increases the amount of time it takes to grow accustomed to a new codebase.

- Without *storytelling* and presenting the most important details upfront, readers can lose interest and get fatigued

##### Whitespace

> Whitespace an atoic component of fostering readable code. It's used to separate thoughts tokens, algorithms, and so on. On a small scale, look at this code. While it is syntatically correct, the lack whitespace makes it hard to read.
> 
> ```ts
> const artists = this.artistRepo,getArtists();const artistNames:string=artists.map(a)=>a.name);
> ```

**5 different types of programming tokens:**

1. Keywords are reserved words: function, class, const.

2. Identifiers are what we are allowed to use as class, variable, and method names: user, userOne, userModel.

3. Operators are tokens that enables us to do logical operations: assignment(=), addition(+), and substraction(-).

4. Separators create whitespace in our doce: tabs, spaces, and newlines

5. Literals are integers, decimals, and strings.

###### Use obvious spacing rules

*Bad horizontal spacing*

```ts
const x=12;

const user = {name: "khali"}


class Employer {
    public update(details: CompanyDetails):Result<UpdateResult>{
    ...
    }
}
```

*Goodhorizontal spacing*

```ts
const x = 12;

const user = { name: "khali" }


class Employer {
    public update (details: CompanyDetails): Result<UpdateResult> {
    ...
    }
}
```

Using horizontal spacing helps to delineate token types. Each line of code is slightly easier to read. Horizontal identation also makes it easier to visualize the *scope* of a method, class, or function. Scope is easy to see by comparing how statements sit up and down the Y-axis.

###### Keep code density low

> Measurement of how many lines of code go without a line break. Line breaks are like commas in English. Both signal a resting point, another step, or a separate thought being expressed. Line breaks help to make code easier to digest.

ex: Apollo GraphQL’s open-source RESTDataSource API.

```ts
export class HTTPCache {
    ...
    async fetch(
        request: Request,
        options: FetchOptions = {},
    ): Promise<Response> {
        /**
        * 1. Create the cache key. You can either supply a cache key or leave it blank
        * and Apollo will use the URL of the request as the key.
        */
        
        const cacheKey = options.cacheKey ? options.cacheKey : request.url;

        /**
        * 2. Using that key, see if the cache has the value already.
        */

        const entry = await this.keyValueCache.get(cachekey);
        
        /**
        * 3. It it doesn't already have the response, we'll need to
        * get it, store the response in the cache, and return the
        * response.
        */

        if(!entry) {
            const response = await this.fetch.httpFetch(reqeust);

            const policy = new CachePolich(
                policyRequestFrom(request),
                policyResponseFrom(response),
            );
            
            return this.storeResponseAndReturnClone(
                response,
                request,
                policy,
                cacheKey,
                options.cacheOptions,
            );
        }

    }
}
 
```

Line breaks help make it easier to digest and comb through potentially challenging logic. It's also good when functions or class methods are kept small. Line breaks between each method are not only convetional, but help readability.

###### Break horizontally when necessary

Strategically break your code horizontally whein it surpasses an appropriate line length(most developers use line length from **80 to 120 characters long**).

*Bad horizontal breaking*

```ts
export class UpvotePost implements UseCase<UpvotePostDTO, Promise<UpvotePostResponse>> {
    ...
    constructor (memberRepo: IMemberRepo, postRepo: IPostRepo, postVotesRepo: IPostVotesRepo, postService: PostService) {
        this.memberRepo = memberRepo;
        this.postRepo = postRepo;
        this.postVotesRepo = postVotesRepo
        this.postService = postService;
    }
}
```

*Good horizontal breaking*

```ts
export class UpvotePost implements UseCase<
    UpvotePostDTO,
    Promise<UpvotePostResponse>
> {
    ...
    constructor (
        memberRepo: IMemberRepo,
        postRepo: IPostRepo,
        postVotesRepo: IPostVoteRepo,
        postService: PostService
    ) {
        this.memberRepo = memberRepo;
        this.postRepo = postRepo;
        this.postVotesRepo = postVotesRepo;
        this.postService = postService;
    }
}
```

###### Prefer smaller files

In Uncle Bob's research on clean code, he discovered the average file size accross several enterprise Java projects were 200 to 500 lines long. Smaller files are generally easier to read and maintain. Less code in a file means less to read.

If there's less to read, there's less to understand, and the surface area of getting confused about what the file **does**(separation of concerns), and what it's **responsible for**(single responsibility) is smaller.

##### Consistency

> Helps readers build comprehension momentum

As you grow acclimated to a new project, your ability to read code and understand how things work should increase exponentially. Humans pick up on patterns. It's how we make sense of the world. Without consistency, we can't identify patterns, and we certainly can't build momentum.

###### Capitalization

The way we use capitalization in programming is strategic. 3 primary capitalization conventions:

- Pascal case, which LooksLikeThis

- Camel case, which looksLikeThis, and

- Underscores/Snake case, which looks_like_this

Capitalization provides additional information about identifiers. ex: camel casing for *variables and methods*, and pascal case for *classes and namespaces*.

in JS & TS, *camelCase* preferred for variables, functions, and class members, while *PascalCase* is preferred for everything else like class names, namespaces, types and interfaces.

###### Whitespace rules

If one developer's code editor adds 4 spaces when they hti the TAB, and another add 2 spaces when they hit TAB, you'll start to resent any developer writing code in files you previously written code, with them messing up your beautiful formatting.

##### Storytelling

> People lose interest and get confused if the most important details aren't provided up front

###### Newspaper Code and the Step-down Principle

In a traditional story, we take the reader through a journey by setting up the scene, introducing them to the characters, then posing the conflict. We don't want to do that with code. Instead, let's get to the interesting stuff **right away**.

> The *newspaper Code Principle* says to **front-load** a file with the **most important things**. By putting the most essential things that we want the reader to know about first, and moving the less critical(yet likely still important) details towards the bottom, readers can learn the primary reason why the class exists in the first place, much quicker.

###### Maintaining a consistent level of abstraction

###### Code should descend in abstraction towards lower-level details

###### Keeping related methods close to each other

##### Enforcing formatting rules with tooling

###### ESLint

###### Prettier

###### Husky

---

## Comments

##### Code explains what and how comments why

##### Comments clutter code

##### When to write comments

##### Demonstration

##### Relationship to Human Centered Design



## Naming Things

##### The seven principles of naming

##### Consistency & uniqueness

##### Understandability

##### Specificity

##### Brevity

##### Searchability

##### Pronounceability

##### Austerity

---

## Errors & Exception Handling

##### Relevant links

---

## Testing

##### BDD & TDD

##### Unit Test

---

## Refactoring

---

## Architecture Basics

jaeger
